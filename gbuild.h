#ifndef GBUILD_H
#define GBUILD_H

/* maximum number of source files that a project can contain */
#define MAX_PROJECT_FILES  16

/* mnemonic is a jump opcode using a relative code position */
#define MNE_RELJUMP        0x01
/* mnemonic is a floating point operation */
#define MNE_FLOAT          0x02
/* mnemonic is memory allocation opcode */
#define MNE_MALLOC         0x04
/* mnemonic memory resize opcode */
#define MNE_RESIZE         0x08

#define SYMBOL_TABLE_BUCKETS    16

#define MAX_OPERANDS       8

#define OP_NONE            0
#define OP_INTEGER         1
#define OP_IDENTIFIER      2
#define OP_STRING          3
#define OP_STACK           4


/*
Specifies the type of a token generated by the lexer.
*/
enum tokentype_t {
    UNKNOWN,
    IDENTIFIER,
    RESERVED,
    INTEGER,
    FLOAT,
    STRING,
    CHAR,
    DICT_WORD,
    OPEN_PARAN,
    CLOSE_PARAN,
    OPEN_BRACE,
    CLOSE_BRACE,
    COMMA,
    SEMICOLON,
    COLON
};

enum statement_type_t {
    STMT_UNKNOWN,
    STMT_BLOCK,
    STMT_ASM
};

enum asm_statement_type_t {
    ASM_UNKNOWN,
    ASM_INSTRUCTION,
    ASM_LABEL
};

typedef struct DICT_WORD {
    char *word;
    unsigned index;

    struct DICT_WORD *next;
} dictword_t;

typedef struct SYMBOL_INFO {
    char *name;
    int type;
    int value;
    unsigned position;

    struct SYMBOL_INFO *next;
} symbol_t;

typedef struct SYMBOL_TABLE {
    symbol_t *symbol_buckets[SYMBOL_TABLE_BUCKETS];
    dictword_t *dictionary;

    struct SYMBOL_TABLE *parent;
} symboltable_t;

/*
Stores information about a single assembly mnemonic.
*/
typedef struct ASM_MNEMONIC {
    const char *mnemonic;
    int opcode;
    int operands;
    int flags;
} mnemonic_t;

/*
Stores information about a project.
*/
typedef struct PROJECT {
    char *project_file;
    unsigned int switches;
    unsigned int file_count;
    char *files[MAX_PROJECT_FILES];
} project_t;

/*
Stores information about a lexer token.
*/
typedef struct LEXER_TOKEN {
    int type;
    char *filename;
    int line_no;
    int col_no;

    union {
        char *text;
        int integer;
    };

    struct LEXER_TOKEN *prev;
    struct LEXER_TOKEN *next;
} lexertoken_t;

/*
Stores a list of lexer tokens.
*/
typedef struct TOKEN_LIST {
    lexertoken_t *first;
    lexertoken_t *last;
} tokenlist_t;

typedef struct ASM_OPERAND {
    int type;
    int is_indirect;
    union {
        int value;
        char *name;
    };
} asmoperand_t;

/*
Stores an assembly statement
*/
typedef struct ASM_INSTRUCTION {
    char *mnemonic;

    int operand_count;
    asmoperand_t operands[MAX_OPERANDS];
} asminst_t;

/*
Stores a assembly label
*/
typedef struct ASM_LABEL {
    char *name;
} asmlabel_t;

/*
Store an assembly statement and a pointrr to the next statement in this block
*/
typedef struct ASM_STATEMENT {
    int type;
    union {
        asminst_t *inst;
        asmlabel_t *label;
    };

    struct ASM_STATEMENT *next;
} asmstmt_t;

/*
Store a block of assembly opcodes
*/
typedef struct ASMBLOCK_DEF {
    asmstmt_t *content;
} asmblock_t;

/*
Stores a block of code
*/
struct STATEMENT_DEF;
typedef struct CODEBLOCK_DEF {
    struct STATEMENT_DEF *content;
} codeblock_t;

/*
Store an individual 'statement'
*/
typedef struct STATEMENT_DEF {
    int type;
    union {
        codeblock_t *code;
        asmblock_t *asm;
    };

    struct STATEMENT_DEF *prev;
    struct STATEMENT_DEF *next;
} statement_t;

/*
Store a function definition and associated code block.
*/
typedef struct FUNCTION_DEF {
    char *name;
    codeblock_t *code;

    struct FUNCTION_DEF *prev;
    struct FUNCTION_DEF *next;
} function_t;

/*
Keep track of all data and content that makes up the content of a glulx game file.
*/
typedef struct GLULXFILE {
    void *constants;
    function_t *functions;
    symboltable_t *global_symbols;
    void *globals;
    void *objects;
} glulxfile_t;

project_t* open_project(const char *project_file);
void free_project(project_t *project);

tokenlist_t* lex_file(glulxfile_t *gamefile, const char *filename);
tokenlist_t* lex_string(glulxfile_t *gamefile, const char *filename, const char *text, size_t length);
tokenlist_t* merge_tokens(tokenlist_t *first, tokenlist_t *second);
void free_tokens(tokenlist_t *tokens);

int parse_file(glulxfile_t *gamedata, tokenlist_t *tokens);

char *strdup (const char *source_string);
int is_reserved_word(const char *word);
mnemonic_t* get_mnemonic(const char *name);

void add_dictionary_word(symboltable_t *table, const char *word);
void index_dictionary(symboltable_t *symbols);
void free_symbol_table(symboltable_t *table);
void free_gamefile(glulxfile_t *what);
void free_function(function_t *what);
void free_codeblock(codeblock_t *what);
void free_asmblock(asmblock_t *what);
void free_asmstmt(asmstmt_t *what);
void free_asmlabel(asmlabel_t *what);
void free_asminst(asminst_t *what);

#endif
